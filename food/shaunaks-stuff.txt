

gremlin> :remote connect tinkerpop.server conf/remote-objects.yaml
==>Connected - localhost/127.0.0.1:8182
gremlin> :> system.createGraph('northwind').ifNotExist().build()
gremlin> :remote config alias g northwind.g
==>g=northwind.g
gremlin> :remote config timeout max
==>Set remote timeout to 2147483647ms
gremlin> :> g.toString()

--------------

gremlin> :> system.createGraph('newgraph3').build()
==>newgraph3
gremlin> :remote config alias g newgraph3.g
==>g=newgraph3.g
gremlin> :> g.toString()
==>graphtraversalsource[dsegraphimpl[newgraph3], standard]
gremlin> :> graph.toString()
==>dsegraphimpl[newgraph3]
gremlin> :> graph.isOpen()
==>true
gremlin> :> g.V().hello()
No signature of method: org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal.hello() is applicable for argument types: () values: []
Possible solutions: sleep(long), sleep(long, groovy.lang.Closure), next(), reset(), tail(), each(groovy.lang.Closure)
Display stack trace? [yN] 
gremlin> 
gremlin> :> graph.isOpen()
==>true
gremlin> 
gremlin> 
gremlin> :> g.getGraph().get().config().set("graph.traversal_sources.aa.type","oltp").applyChanges()
==>null
gremlin> :remote config alias aa newgraph3.aa
==>aa=newgraph3.aa
gremlin> :> aa.toString()
==>graphtraversalsource[dsegraphimpl[newgraph3], standard]
gremlin> :> aa.V().hello()
No signature of method: org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal.hello() is applicable for argument types: () values: []
Possible solutions: sleep(long), sleep(long, groovy.lang.Closure), next(), reset(), tail(), each(groovy.lang.Closure)
Display stack trace? [yN] 
gremlin> :> graph.toString()
==>dsegraphimpl[newgraph3]
gremlin> :> graph.isOpen()
==>true
gremlin>

----------
// client-server related references
cluster = Cluster.build().create()
client.submit('system.createGraph("enron").ifNotExist().build()').all().get()
client = cluster.connect().alias("enron.g")
client.submit("graph.schema().clear()").all().get()

start = system.currentTimeMillis() // start time for the parsing+loading
count = 0; //how many edges have been processed
map = [from: [], to: []] //HashMap for storing parsed data

// command that is submitted to the Gremlin Server
command =  "for(int i = 0; i < from.size(); i++){ "+
           "def sourceV = g.V().has('email', 'emailId', from[i]).tryNext().orElseGet {graph.addVertex(label, 'email', 'emailId', from[i])};" +
           "def targetV = g.V().has('email', 'emailId', to[i]).tryNext().orElseGet {graph.addVertex(label, 'email', 'emailId', to[i])};" +
           "sourceV.addEdge('emailed', targetV)}"

new File('/var/lib/automaton/tests/data/graph/email-Enron.txt').eachLine { def line ->
    map.toString()
    //println "Made it here: " + count
    if (line.startsWith('#')) {
        // ignore the comments at beginning of this data file
        return
    }
    count = count + 1
    // parsing the line...
    parts = line.split('\t')
    source = parts[0].toInteger()
    target = parts[1].toInteger()

    // filling up our HashMap...
    map.from.add(source)
    map.to.add(target)

    // send command to the Gremlin Server
    if(count%100 == 0){
        // NOTE: each client.submit() ends with a graph.tx().commit()
        client.submit(command, map).all().get()
        println "Committed " + count + " edges to DseGraph instance."
        // clear out the HashMap, for the next batch
        map = [from: [], to: []]
    }
}
// get the remaining vertices and edges to the Gremlin Server
client.submit(command).all().get()

// finish timing this loading process
def total_time = System.currentTimeMillis() - start
return total_time/1000
